<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>Presentation</title>

		<link rel="stylesheet" href="../external/reveal.js/dist/reset.css">
		<link rel="stylesheet" href="../external/reveal.js/dist/reveal.css">
		<link rel="stylesheet" href="../external/reveal.js/dist/theme/black.css">

		<!-- Theme used for syntax highlighted code -->
		<link rel="stylesheet" href="../external/reveal.js/plugin/highlight/monokai.css">
		<link rel="stylesheet" href="style.css">
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section>
					<h1>entiteter, komponenter och system</h1>
				</section>
				<section>
					<h3>Vad presentationen g친r igenom</h3>
					<ul>
						<li class="fragment">Andra modeller f칬r att definera objekt i spelv칛rlden</li>
						<li class="fragment">The what, vad 칛r ett entity component system?</li>
						<li class="fragment">The why, varf칬r skulle vi vilja anv칛nda det?</li>
						<li class="fragment">The how, hur g칬r jag mitt eget?</li>
					</ul>
				</section>
				<section>
					<h3>Arvsmodellen 游눨</h3>
					<ul>
						<li>Objekt defineras statiskt i dess arvshierarki</li>
						<li>Leder l칛tt till blobbar och refaktoriseringar</li>
						<li>Sv친rt f칬r att optimera f칬r h칬g prestanda</li>
					</ul>
				</section>
				<section>
					<img src="media/object-heirarchy.png" alt="">
				</section>
				<section>
					<h3>GameObject-component modell</h3>
					<ul>
						<li>Anv칛nds av spelmotorer som Unity</li>
						<li>Objekt defineras i runtime av sina komponenter</li>
						<li>Beteende defineras med virtuella funktioner</li>
						<li>Fortfarande sv친rt att optimera f칬r h칬g prestanda</li>
					</ul>
					
				</section>
				<section>
					<img src="media/unity_composes.jpg" alt="">
				</section>
				<section>
					<h4>Pseudokod</h4>
					<pre><code data-trim data-noescape data-line-numbers="1-5|7-11|13-17|19-25">							
						class Component
						{
						public:
							virtual void Update(GameObject* aOwner, float aDT) = 0;
						};

						void GameObject::Update(float aDT)
						{
							for (Component* component : myComponents)
								component->Update(this, aDT);
						}

						void Scene::Update(float aDT)
						{
							for (GameObject* gameObject : myGameObjects)
								gameOject->Update(aDT);
						}

						void PlayerComponent::Update(GameObject* aOwner, foat aDT)
						{
							if (Input::Left())
								aOwner->myPosition += Vector2(-1,0) * mySpeed * aDT;
							if (Input::Right())
								aOwner->myPosition += Vector2(1,0) * mySpeed * aDT;
						}
					</code></pre>
				</section>
				<section>
					<h3>Vad 칛r ett entity component system?</h3>
					<ul>
						<li>En dynamisk beskrivning av objekt i spelv칛rlden</li>
						<li>Arkitektur och designm칬nster</li>
						<li>Dataorienterad design</li>
					</ul>
				</section>
				<section>
					<h3>Entititer</h3>
					<ul>
						<li>
							Entititer representerar ett individuellt objekt i v칛rlden.
							De 칛r byggstenarna av ett ecs, och agerar som en samling av komponenter.
						</li>
						<li>
							Likt GameObjects i Unity ni 칛r vana med, men i ett ECS 칛r 
							entiteter bara ett unikt id, oftast implementerat som en unsigned int.
						</li>
						<li>
							Dessa entiteter anv칛nds som en nyckel till en associativ container, 
							som kopplar entiteten till en komponent.
						</li>
					</ul>
					
				</section>
				<section>
					<h3>Komponenter</h3>
					<ul>
						<li>
							Definerar beteende och egenskaper av en entitet.
						</li>
						<li>
							츿r oberoende och enkapsulerade.
						</li>
						<li>
							Kan l칛ggas till och tas bort fr친n entiteter i runtime.
						</li>
					</ul>
				</section>
				<section>
					<h3>System</h3>
					<ul>
						<li>
							System har inget eget tillst친nd, 
							det utf칬r beteendet som defineras av en upps칛ttning komponenter
						</li>
						<li>
							Fokuserar p친 en specifik uppgift, 
							ett system har ingen koppling till 
							komponenter som inte ber칬r den uppgiften.
						</li>
					</ul>
				</section>
				<section>
					<h2>F칬rdelar - Varf칬r</h2>
				</section>
				<section>
					<h3>Flexibilitet 游뱢</h3>
					<ul>
						<li>Enkapsulering</li>
					</ul>
				</section>
				<section>
					<h3>Prestanda 游끢</h3>
					<ul>
						<li class="fragment">
							Dataorientering, optimering f칬r cache
							<ul>
								<li class="fragment">Komponenter av samma typ ligger p친 rad i minnet</li>
								<li class="fragment">Iterering av komponenter kan g칬ras linj칛rt</li>
							</ul>
						</li>
						<li class="fragment">triviellt flertr친dad arkitektur</li>
					</ul>
				</section>
				<section>
					<h3>Dataorientering - cache is king</h3>
					<ul>
						<li>L칛sa minne fr친n RAM 칛r 游낿, d칛rf칬r cachar vi ofta anv칛nt minne.</li>
						<li>N칛r minne v칛l l칛ses fr친n RAM g칬rs det i storleken av en cache-line, typiskt sett 64 bytes p친 x86/x64</li>
					</ul>
					<br>
					<br>
				</section>
				<section>
					<h4>Med detta i 친tanke vill vi</h4>
					<ul>
						<li>T칛nka p친 datan i strukturerna vi anv칛nder</li>
						<li>Hur kan v친ra algoritmer och system optimera f칬r cache</li>
						<li>Undvika separata minnesallokeringar, allokera minne i chunks</li>
					</ul>
				</section>
				<section>
					<h3>Exempel - parallel arrays</h3>
					<div class="fragment">
						<h4>Objektorienterat</h4>
						<pre><code data-trim data-noescape data-line-numbers="">							
							struct AssociativeArray
							{
								Pair&lt;KeyType, ValueType&gt; myData[SIZE];
							};
						</code></pre>
					</div>
					<div class="fragment">
						<h4>Dataorienterat</h4>
						<pre><code data-trim data-noescape data-line-numbers="">							
							struct AssociativeArray
							{
								KeyType myKeys[SIZE];
								ValueType myValues[SIZE];
							};
						</code></pre>
					</div>
				</section>
				<section>
					<h4>Objektorienterat</h4>
					<img src="media/AssociativeArray.png" alt="">
					<h4>Dataorienterat</h4>
					<img src="media/ParallelArraysScaled.png" alt="">
				</section>
				<section>

					<h4>Quiz</h4>

					<section>
						<pre class=""><code data-trim data-noescape data-line-numbers="">					
							struct Pair
							{
								char myFirst;
								int mySecond;
							};
							std::cout &lt;&lt; sizeof(Pair) &lt;&lt; '\n';
						</code></pre>
						<p>Pair = <span class="fragment">8</span></p>
					</section>
					
					<section>
						<pre><code data-trim data-noescape data-line-numbers="">
							struct MyStruct
							{
								char a;
								int b;
								char c;
							};
							std::cout &lt;&lt; sizeof(MyStruct) &lt;&lt; '\n';
						</code></pre>
						<p>MyStruct = <span class="fragment">12</span></p>
	
						<pre><code data-trim data-noescape data-line-numbers="">
							struct TheirStruct
							{
								int b;
								char a;
								char c;
							};
							std::cout &lt;&lt; sizeof(TheirStruct) &lt;&lt; '\n';
						</code></pre>
						<p>TheirStruct = <span class="fragment">8</span></p>
					</section>
					

				</section>
				<section>
					<h4>Objektorienterat</h4>
					<img src="media/AssociativeArrayGarbageMemory.png" alt="">
					<h4>Dataorienterat</h4>
					<img src="media/ParallelArraysScaled.png" alt="">
				</section>
				<!--
					en cpu l칛ser typiskt sett en WORD - 4 bytes 친t g친ngen,
					g친r att aligna med #pragma pack(push, 1).

					ifall minne inte ligger alignat till en word-storlek, kommer cpun beh칬va l칛sa in den i 2 register, 
					sen shifta ihop minnet till ett.
				-->
				<section>
					<h3>Tr친dning</h3>
					eftersom system bara kan modifiera komponenterna de arbetar p친, s친 kan vi vara s칛kra p친
					att 2 tr친dar inte kommer hamna i ett race condition.
					

					<img src="media/DependencyGraph.png" alt="">
				</section>
				<section>
					<h3>Kod</h3>
				</section>
				<section >
					Entiteter, f칬delsen och d칬den
					<pre><code data-trim data-noescape data-line-numbers="1-2|4-11|13-16">
						#define MAX_ENTITIES 1000
						using Entity = uint32_t;

						Entity Create()
						{
							if (myFreeEntities.Size())
							{
								return myFreeEntities.Dequeue();
							}
							return myNext++;
						}

						void Remove(Entity aEntity)
						{
							myFreeEntities.Enqueue(aEntity);
						}
						Entity myNext = 0;
						CommonUtilities::Heap&lt;Entity&gt; myFreeEntities;

					</code></pre>
				</section>
				<section>
					<h4>Komponenter</h4>
					<ul>
						<li>Vill vi beh친lla p친 rad i minnet</li>
						<li>Det finns flera s칛tt att g칬ra det</li>
						<li>Vi anv칛nder en sparse-set liknande struktur</li>
					</ul>
					<img src="media/sparse-set-remove-item.png" alt="" style="max-width: 50%">
				</section>
				<section>
					<pre><code data-trim data-noescape data-line-numbers="56-60|5-14|16-27">
						template &lt;typename T&gt;
						class ComponentArray
						{
						public:
							T& Add(Entity aEntity)
							{
								assert(!Contains(aEntity));
								myDense[mySize] = aEntity;
								mySparse[aEntity] = mySize;
								myComponents[mySize] = T();
								++mySize;
							
								return myComponents[mySize-1];
							}

							void Remove(Entity aEntity)
							{
								assert(Contains(aEntity));
								
								Entity denseIndex = mySparse[aEntity];

								--mySize;
								std::swap(myComponents[mySize], myComponents[denseIndex]);
								std::swap(myDense[mySize], myDense[denseIndex]);
								mySparse[myDense[denseIndex]] = denseIndex;

								T tmp = std::move(myComponents[mySize]);
							}

							bool Contains(Entity aEntity)
							{
								return aEntity < MAX_ENTITIES && mySparse[aEntity] < mySize && myDense[mySparse[aEntity]] == aEntity;
							}

							T& Get(Entity aEntity)
							{
								assert(Contains(aEntity));
								return myComponents[mySparse[aEntity]];
							}

							T* GetComponents()
							{
								return myComponents;
							}

							Entity GetEntityByIndex(size_t aIndex)
							{
								return myDense[aIndex];
							}

							size_t Size()
							{
								return mySize;
							}
						private:
							T myComponents[MAX_ENTITIES];
							Entity myDense[MAX_ENTITIES];
							Entity mySparse[MAX_ENTITIES];
							size_t mySize = 0;
						}
					</code></pre>
				</section>
				<section>
					Exempelsystem
					<pre ><code data-trim data-noescape data-line-numbers="3-4,13|5|6-7|9-10,12" style="font-size:0.7em">
						void Render(ComponentArray&lt;Model&gt;&amp; someModels, ComponentArray&lt;Transform&gt;&amp; someTransforms)
						{
							for (int i = 0; i < someModels.Size(); ++i)
							{
								Entity entity = someModels.GetEntityByIndex(i);
								if (!someTransforms.Contains(entity))
									continue;

								Model&amp; model = someModels.Get(entity);
								Transform&amp; transform = someTransforms.Get(entity);

								RenderModel(model, transform);
							}
						}

					</code></pre>
				</section>
			</div>
		</div>

		<script src="../external/reveal.js/dist/reveal.js"></script>
		<script src="../external/reveal.js/plugin/notes/notes.js"></script>
		<script src="../external/reveal.js/plugin/markdown/markdown.js"></script>
		<script src="../external/reveal.js/plugin/highlight/highlight.js"></script>
		<script>
			// More info about initialization & config:
			// - https://revealjs.com/initialization/
			// - https://revealjs.com/config/
			Reveal.initialize({
				hash: true,

				// Learn about plugins: https://revealjs.com/plugins/
				plugins: [ RevealMarkdown, RevealHighlight, RevealNotes ]
			});
		</script>
	</body>
</html>
